<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake Game Smooth</title>
<style>
body {
  margin: 0;
  padding: 12px;
  font-family: Arial, Helvetica, sans-serif;
  background: #0b2b2e;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
}
canvas {
  background: #0f3b3f;
  border: 6px solid #234;
  image-rendering: pixelated;
  margin-bottom: 12px;
}
.hud {
  display: flex;
  gap: 12px;
  align-items: center;
}
button {
  padding: 8px 12px;
  border-radius: 8px;
  border: none;
  background: #2d9;
  cursor: pointer;
  font-size: 16px;
}
#controls {
  display: grid;
  grid-template-columns: 60px 60px 60px;
  grid-template-rows: 60px 60px;
  gap: 6px;
  justify-items: center;
  align-items: center;
}
#controls button { width: 60px; height: 60px; font-size: 24px; }
#up { grid-column: 2; grid-row: 1; }
#left { grid-column: 1; grid-row: 2; }
#down { grid-column: 2; grid-row: 2; }
#right { grid-column: 3; grid-row: 2; }
@media(max-width:600px){
  canvas { width: 320px; height: 320px; }
  #controls { grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(2, 50px); gap: 4px; }
  #controls button { width: 50px; height: 50px; font-size: 20px; }
}
</style>
</head>
<body>

<h2>Snake</h2>
<div class="hud">
  <div>Score: <span id="score">0</span></div>
  <button id="restart">Restart</button>
</div>
<canvas id="gameCanvas" width="360" height="360"></canvas>

<div id="controls">
  <button id="up">↑</button>
  <button id="left">←</button>
  <button id="down">↓</button>
  <button id="right">→</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const CELL = 20;
  const COLS = canvas.width / CELL;
  const ROWS = canvas.height / CELL;

  let snake = [];
  let dir = {x:1, y:0};
  let nextDir = {x:1, y:0};
  let food;
  let score = 0;
  let running = true;
  let tickInterval;

  function randCell() {
    return { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
  }

  function spawnFood() {
    let f;
    do { f = randCell(); } while(snake.some(s => s.x === f.x && s.y === f.y));
    food = f;
  }

  function init() {
    snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
    dir = {x:1, y:0};
    nextDir = {x:1, y:0};
    score = 0;
    scoreEl.textContent = score;
    running = true;
    spawnFood();
    if(tickInterval) clearInterval(tickInterval);
    tickInterval = setInterval(step, 140);
    draw(); // initial draw
  }

  function step() {
    if(!running) return;

    // apply queued direction
    dir = nextDir;

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // wrap-around
    if(head.x < 0) head.x = COLS-1;
    if(head.x >= COLS) head.x = 0;
    if(head.y < 0) head.y = ROWS-1;
    if(head.y >= ROWS) head.y = 0;

    // collision with self
    if(snake.some(s => s.x === head.x && s.y === head.y)) {
      die();
      return;
    }

    snake.unshift(head);

    // eat food
    if(head.x === food.x && head.y === food.y){
      score += 10;
      scoreEl.textContent = score;
      spawnFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function die() {
    running = false;
    clearInterval(tickInterval);
    ctx.fillStyle = '#ff4d4d';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    setTimeout(draw, 120);
  }

  function draw() {
    ctx.fillStyle = '#072d2f';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // grid
    ctx.strokeStyle='rgba(255,255,255,0.03)';
    ctx.lineWidth=1;
    for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*CELL,0);ctx.lineTo(x*CELL,canvas.height);ctx.stroke();}
    for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*CELL);ctx.lineTo(canvas.width,y*CELL);ctx.stroke();}

    // food
    ctx.fillStyle = '#ffde59';
    ctx.fillRect(food.x*CELL+3, food.y*CELL+3, CELL-6, CELL-6);

    // snake
    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      ctx.fillStyle = i===0?'#00ff9d':'#0df0b2';
      ctx.fillRect(s.x*CELL+2,s.y*CELL+2,CELL-4,CELL-4);
    }
  }

  // keyboard controls
  function setDir(x,y){
    if(snake.length>1 && snake[0].x + x === snake[1].x && snake[0].y + y === snake[1].y) return;
    nextDir = {x,y};
  }

  document.addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(k==='arrowup'||k==='w') setDir(0,-1);
    if(k==='arrowdown'||k==='s') setDir(0,1);
    if(k==='arrowleft'||k==='a') setDir(-1,0);
    if(k==='arrowright'||k==='d') setDir(1,0);
    if(k==='r') init();
  });

  // mobile buttons
  document.getElementById('up').addEventListener('click', ()=> setDir(0,-1));
  document.getElementById('down').addEventListener('click', ()=> setDir(0,1));
  document.getElementById('left').addEventListener('click', ()=> setDir(-1,0));
  document.getElementById('right').addEventListener('click', ()=> setDir(1,0));
  document.getElementById('restart').addEventListener('click', init);

  // swipe
  let tStart=null;
  canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; tStart={x:t.clientX,y:t.clientY}; }, {passive:true});
  canvas.addEventListener('touchend', e=>{
    if(!tStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX-tStart.x, dy = t.clientY-tStart.y;
    if(Math.abs(dx)>Math.abs(dy)){
      if(dx>20) setDir(1,0); else if(dx<-20) setDir(-1,0);
    } else {
      if(dy>20) setDir(0,1); else if(dy<-20) setDir(0,-1);
    }
    tStart=null;
  }, {passive:true});

  init();
})();
</script>

</body>
</html>
